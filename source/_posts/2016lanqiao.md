---
title: 2016 第七届蓝桥杯 c/c++ B组省赛真题及解题报告
date: 2016-3-20
tags: 蓝桥杯
---
#**2016 第七届蓝桥杯 c/c++ B组省赛真题及解题报告**


<font color='red'>勘误1：第6题第4个 if最后一个条件粗心写错了，答案应为1580。条件应为`abs(a[3]-a[7])!=1`,宝宝心理苦啊！！感谢zzh童鞋的提醒。</font>

<font color='red'>勘误2：第7题在判断连通的时候条件写错了，后两个if条件中是应该是<=12 落了一个等于号，正确答案应为116。</font>

>##**1.煤球数目**

>有一堆煤球，堆成三角棱锥形。具体：
第一层放1个，
第二层3个（排列成三角形），
第三层6个（排列成三角形），
第四层10个（排列成三角形），
....
如果一共有100层，共有多少个煤球？

>请填表示煤球总数目的数字。
注意：你提交的应该是一个整数，不要填写任何多余的内容或说明性文字。

###解题思路
第n层的煤球数是n*(n+1)/2个,共100层，放进for循环累加一下。注意求的是前一百层一共,答案为171700
###代码

```c
#include <cstdio>
#include <algorithm>
using namespace std;
int main(){
	long long x=0;
	for(int i=1;i<101;i++){
		//printf("i:%d\n",(1+i)*(i)/2);
		x+=(1+i)*(i)/2;
	}
	printf("x:%lld\n",x);
	return 0;
}
```
---
>##**2.生日蜡烛**

>某君从某年开始每年都举办一次生日party，并且每次都要吹熄与年龄相同根数的蜡烛。

>现在算起来，他一共吹熄了236根蜡烛。

>请问，他从多少岁开始过生日party的？

>请填写他开始过生日party的年龄数。
注意：你提交的应该是一个整数，不要填写任何多余的内容或说明性文字。

###解题思路

假设他从第i年开始过，一共过了k年，写两个for穷举一下，1-100范围内，利用等差数列求和公式，满足这个式子的$(2*i+k)*(k+1)==472$就是答案，最后答案为26。

###代码

```c
#include <cstdio>
int main(){
	for(int i=1;i<100;i++){
		for(int k=1;k<100;k++){
			if((2*i+k)*(k+1)==472){
				printf("i:%d k:%d\n",i,k);
			}
		}
	}
	return 0;
}
```
---
>##**3.凑算式**

>![这里写图片描述](http://img.blog.csdn.net/20160320152805039)
	 
	 
>这个算式中A~I代表1~9的数字，不同的字母代表不同的数字。

>比如：
6+8/3+952/714 就是一种解法，
5+3/1+972/486 是另一种解法。

>这个算式一共有多少种解法？

>注意：你提交应该是个整数，不要填写任何多余的内容或说明性文字。

###解题思路
利用c++中的全排列函数全排列一下1-9，然后条件判断一下就可以了。
答案为29

###代码

```c
#include <cstdio>
#include <algorithm>
using namespace std;
int main(){
	//         a,b,c,d,e,f,g,h,i
	int a[10]={1,2,3,4,5,6,7,8,9},count=0;
	do{
		int ghi=(a[6]*100+a[7]*10+a[8]);
		int def=a[3]*100+a[4]*10+a[5];
		if((a[0]*a[2]*ghi)+(a[1]*ghi)+(def*a[2])==10*a[2]*ghi){
			count++;
			printf("%d+%d/%d+%d%d%d/%d%d%d=10\n",a[0],a[1],a[2],a[3],a[4],a[5],a[6],a[7],a[8]);
		}
	}while(next_permutation(a,a+9));
	printf("cout:%d\n",count);
	return 0;
}
```
---
>##**4.快速排序**

>排序在各种场合经常被用到。
快速排序是十分常用的高效率的算法。

>其思想是：先选一个“标尺”，
用它把整个队列过一遍筛子，
以保证：其左边的元素都不大于它，其右边的元素都不小于它。

>这样，排序问题就被分割为两个子区间。
再分别对子区间排序就可以了。

>下面的代码是一种实现，请分析并填写划线部分缺少的代码。
>
```c
#include <stdio.h>

void swap(int a[], int i, int j)
{
	int t = a[i];
	a[i] = a[j];
	a[j] = t;
}

int partition(int a[], int p, int r)
{
    int i = p;
    int j = r + 1;
    int x = a[p];
    while(1){
        while(i<r && a[++i]<x);
        while(a[--j]>x);
        if(i>=j) break;
        swap(a,i,j);
    }
	______________________;
    return j;
}

void quicksort(int a[], int p, int r)
{
    if(p<r){
        int q = partition(a,p,r);
        quicksort(a,p,q-1);
        quicksort(a,q+1,r);
    }
}
    
int main()
{
	int i;
	int a[] = {5,13,6,24,2,8,19,27,6,12,1,17};
	int N = 12;
	
	quicksort(a, 0, N-1);
	
	for(i=0; i<N; i++) printf("%d ", a[i]);
	printf("\n");
	
	return 0;
}
```

>注意：只填写缺少的内容，不要书写任何题面已有代码或说明性文字。

###解题思路
很常规的快速排序，不会填的自己翻一下数据结构的书。

###填空代码

```c
swap(a,j,p)
```

---
>##**5.抽签**

>X星球要派出一个5人组成的观察团前往W星。
其中：
A国最多可以派出4人。
B国最多可以派出2人。
C国最多可以派出2人。
....

>那么最终派往W星的观察团会有多少种国别的不同组合呢？

>下面的程序解决了这个问题。
数组a[] 中既是每个国家可以派出的最多的名额。
程序执行结果为：
DEFFF
CEFFF
CDFFF
CDEFF
CCFFF
CCEFF
CCDFF
CCDEF
BEFFF
BDFFF
BDEFF
BCFFF
BCEFF
BCDFF
BCDEF
....
(以下省略，总共101行)


```
#include <stdio.h>
#define N 6
#define M 5
#define BUF 1024

void f(int a[], int k, int m, char b[])
{
	int i,j;
	
	if(k==N){ 
		b[M] = 0;
		if(m==0) printf("%s\n",b);
		return;
	}
	
	for(i=0; i<=a[k]; i++){
		for(j=0; j<i; j++) b[M-m+j] = k+'A';
		______________________;  //填空位置
	}
}
int main()
{	
	int  a[N] = {4,2,2,1,1,3};
	char b[BUF];
	f(a,0,M,b);
	return 0;
}
```

>仔细阅读代码，填写划线部分缺少的内容。

>注意：不要填写任何已有内容或说明性文字。
###解题思路
很明显是一个递归搜索题，第一个参数和最后一个参数肯定是不变的，第二个参数的意思是现在该选哪一个国家，第三个参数的意思是还有几个没有选。

###代码

```c
f(a,k+1,m-i,b)
```
---

>##**6.方格填数**

>如下的10个格子
![这里写图片描述](http://img.blog.csdn.net/20160320154048055)

>填入0~9的数字。要求：连续的两个数字不能相邻。
（左右、上下、对角都算相邻）

>一共有多少种可能的填数方案？

>请填写表示方案数目的整数。
注意：你提交的应该是一个整数，不要填写任何多余的内容或说明性文字。

###解题思路
还是利用c++的全排列函数，然后写个judge函数来判断一下相邻的数字是不是连续的就可以了，条件写的时候比较麻烦，但是复制粘贴就好啦，按一定的顺序写，不要漏了。

###代码

```c
#include <cstdio>
#include <algorithm>
#include <cmath>
using namespace std;
bool judge(int a[]){
	if(abs(a[0]-a[1])!=1&&abs(a[0]-a[4])!=1&&abs(a[0]-a[5])!=1&&abs(a[0]-a[3])!=1)
	if(abs(a[1]-a[2])!=1&&abs(a[1]-a[4])!=1&&abs(a[1]-a[5])!=1&&abs(a[1]-a[6])!=1)
	if(abs(a[2]-a[5])!=1&&abs(a[2]-a[6])!=1)
	if(abs(a[3]-a[4])!=1&&abs(a[3]-a[8])!=1&&abs(a[4]-a[7])!=1)
	if(abs(a[4]-a[5])!=1&&abs(a[4]-a[7])!=1&&abs(a[4]-a[8])!=1&&abs(a[4]-a[9])!=1)
	if(abs(a[5]-a[6])!=1&&abs(a[5]-a[8])!=1&&abs(a[5]-a[9])!=1)
	if(abs(a[6]-a[9])!=1)if(abs(a[7]-a[8])!=1)if(abs(a[8]-a[9])!=1)return true;
	return false;
}
int main(){
	int a[10]={0,1,2,3,4,5,6,7,8,9},count=0;
	do{
		if(judge(a)){
			count++;
			printf("  %d %d %d\n%d %d %d %d\n%d %d %d  \n",a[0],a[1],a[2],a[3],a[4],a[5],a[6],a[7],a[8],a[9]);
		}
	}while(next_permutation(a,a+10));
	printf("cout:%d\n",count);
	return 0;
}
```

---
>##**7.剪邮票**
![图1](http://img.blog.csdn.net/20160320154417617)
**图1**
![图2](http://img.blog.csdn.net/20160320154444117)
![图3](http://img.blog.csdn.net/20160320154507898)
>如【图1.jpg】, 有12张连在一起的12生肖的邮票。
现在你要从中剪下5张来，要求必须是连着的。
（仅仅连接一个角不算相连）
比如，【图2.jpg】，【图3.jpg】中，粉红色所示部分就是合格的剪取。

>请你计算，一共有多少种不同的剪取方法。

>请填写表示方案数目的整数。
注意：你提交的应该是一个整数，不要填写任何多余的内容或说明性文字。

###解题思路
暴力枚举剪下来的部分的数字，复杂度是$12^5$，然后判断一下是否相连，判断的时候利用了像广搜BFS一样的思想用一个队列，从一个点开始，加入与该点相连的所有在剪下来的部分中的数，然后就和广搜的思想一样了。结果填空，不用担心时间，但速度也很快。

###代码

```c
#include <cstdio>
#include <queue>
#define rep(x,n) for(x=n;x<13;x++)
using namespace std;
bool judge(int a[]){
	queue<int> q;
	q.push(a[0]);
	int c=0,find[20]={0};
	for(int i=0;i<5;i++){
		find[a[i]]=1;
	}
	if(a[0]==3&&a[1]==6&&a[2]==7&&a[3]==8&&a[4]==11){
		printf("test\n");
	}
	int vis[20]={0};
	vis[a[0]]=1;
	while(!q.empty()){
		int t=q.front();
		//printf("%d\n",t);
		q.pop();
		c++;
		if(t-1>0&&vis[t-1]!=1&&find[t-1]&&t!=5&&t!=9){
			vis[t-1]=1;
			q.push(t-1);
		}
		if(t-4>0&&vis[t-4]!=1&&find[t-4]){
			vis[t-4]=1;
			q.push(t-4);
		}
		if(t+1<12&&vis[t+1]!=1&&find[t+1]&&(t!=4&&t!=8))
		{
			vis[t+1]=1;
			q.push(t+1);
		}
		if(t+4<12&&vis[t+4]!=1&&find[t+4]){
			vis[t+4]=1;
			q.push(t+4);
		}
			
	}
	if(c==5)return true;
	return false;
}
int main(){
	int a[6],count=0;
	rep(a[0],1)rep(a[1],a[0])rep(a[2],a[1])rep(a[3],a[2])rep(a[4],a[3]){
	//rep(a[0],1)rep(a[1],1)rep(a[2],1)rep(a[3],1)rep(a[4],1){
		if(a[0]==a[1]||a[0]==a[2]||a[0]==a[3]||a[0]==a[4]||a[1]==a[2]||a[1]==a[3]||a[1]==a[4]||a[2]==a[3]||a[2]==a[4]||a[3]==a[4])
		continue;
		if(judge(a)){
			
			int find[20]={0};
			for(int i=0;i<5;i++){
				find[a[i]]=1;
			}
			printf("Case%d:\n",count+1);
			for(int i=1;i<=3;i++){
				for(int j=1;j<5;j++){
					if(find[(i-1)*4+j])printf("%3c",'*');
					else printf("%3d",(i-1)*4+j);
				}
				printf("\n");
			}
			
			count++;
		}
		
		//printf("%d %d %d %d %d\n",a[0],a[1],a[2],a[3],a[4]);
	}
	printf("count:%d\n",count);
	return 0;
}
```
---

>##**8.四平方和**

>四平方和定理，又称为拉格朗日定理：
每个正整数都可以表示为至多4个正整数的平方和。
如果把0包括进去，就正好可以表示为4个数的平方和。

>比如：
5 = 0^2 + 0^2 + 1^2 + 2^2
7 = 1^2 + 1^2 + 1^2 + 2^2
（^符号表示乘方的意思）

>对于一个给定的正整数，可能存在多种平方和的表示法。
要求你对4个数排序：
0 <= a <= b <= c <= d
并对所有的可能表示法按 a,b,c,d 为联合主键升序排列，最后输出第一个表示法


>程序输入为一个正整数N (N<5000000)
>要求输出4个非负整数，按从小到大排序，中间用空格分开

>例如，输入：
5
则程序应该输出：
0 0 1 2

>再例如，输入：
12
则程序应该输出：
0 2 2 2

>再例如，输入：
773535
则程序应该输出：
1 1 267 838

>资源约定：
峰值内存消耗 < 256M
CPU消耗  < 3000ms

>请严格按要求输出，不要画蛇添足地打印类似：“请您输入...” 的多余内容。

>所有代码放在同一个源文件中，调试通过后，拷贝提交该源码。

>注意: main函数需要返回0
注意: 只使用ANSI C/ANSI C++ 标准，不要调用依赖于编译环境或操作系统的特殊函数。
注意: 所有依赖的函数必须明确地在源文件中 #include <xxx>， 不能通过工程设置而省略常用头文件。

>提交时，注意选择所期望的编译器类型。

###解题思路
直接枚举从小的开始，枚举到答案就可以return了，不过注意的是只枚举三个数，最后一个数可以倒着求出来，然后正过来验证，看代码就明白啦。

###代码

```c
#include <cstdio>
#include <cmath>
#define MAXN 2300
//注意范围，题目给的范围枚举到2300就够了
int flag=0;
int main(){
	int n;
	scanf("%d",&n);
	for(int i=0;i<MAXN;i++){
		if(i*i<=n)
		for(int j=i;j<MAXN;j++){
			if(i*i+j*j<=n)
			for(int k=j;k<MAXN;k++){
				int l=(int)sqrt(n-i*i-j*j-k*k);//算出第4个数
				if(i*i+j*j+k*k+l*l==n){
					printf("%d %d %d %d",i,j,k,l);
					return 0;
				}
			}
		}
	}
	return 0;
}
```

---
>##**9.交换瓶子**

>有N个瓶子，编号 1 ~ N，放在架子上。

>比如有5个瓶子：
2 1 3 5 4

>要求每次拿起2个瓶子，交换它们的位置。
经过若干次后，使得瓶子的序号为：
1 2 3 4 5

>对于这么简单的情况，显然，至少需要交换2次就可以复位。

>如果瓶子更多呢？你可以通过编程来解决。

>输入格式为两行：
第一行: 一个正整数N（N<10000）, 表示瓶子的数目
第二行：N个正整数，用空格分开，表示瓶子目前的排列情况。

>输出数据为一行一个正整数，表示至少交换多少次，才能完成排序。

>例如，输入：
5
3 1 2 5 4

>程序应该输出：
3

>再例如，输入：
5
5 4 3 2 1

>程序应该输出：
2

>资源约定：
峰值内存消耗 < 256M
CPU消耗  < 1000ms

>请严格按要求输出，不要画蛇添足地打印类似：“请您输入...” 的多余内容。

>所有代码放在同一个源文件中，调试通过后，拷贝提交该源码。

>注意: main函数需要返回0
注意: 只使用ANSI C/ANSI C++ 标准，不要调用依赖于编译环境或操作系统的特殊函数。
注意: 所有依赖的函数必须明确地在源文件中 #include <xxx>， 不能通过工程设置而省略常用头文件。

>提交时，注意选择所期望的编译器类型。

###解题思路
这个题乍一看觉得和排序有关，其实应该是和置换有关。
可以看一下置换里的闭包的概念，求的就是闭包的长度，具体思路等会儿补上。

###代码

```c
#include <cstdio>
int a[10001],b[10001];
int f(int x){
	int t=x,sum=0;
	//printf("x:%d ",x);
	while(a[x]!=t){
		//printf("%d ",a[x]);
		sum++;
		b[a[x]]=1;
		x=a[x];
	}
	//printf("\n");
	return sum;
}
int main(){
	int n,count=0;
	scanf("%d",&n);
	for(int i=1;i<=n;i++){
		scanf("%d",&a[i]);
	}
	for(int i=1;i<=n;i++){
		if(b[i])continue;
		count+=f(i);
	}
	printf("%d",count);
	return 0;
}

```
---
>##10.**最大比例**

>X星球的某个大奖赛设了M级奖励。每个级别的奖金是一个正整数。
并且，相邻的两个级别间的比例是个固定值。
也就是说：所有级别的奖金数构成了一个等比数列。比如：
16,24,36,54
其等比值为：3/2

>现在，我们随机调查了一些获奖者的奖金数。
请你据此推算可能的最大的等比值。

>输入格式：
第一行为数字N，表示接下的一行包含N个正整数
第二行N个正整数Xi(Xi<1 000 000 000 000)，用空格分开。每个整数表示调查到的某人的奖金数额

>要求输出：
一个形如A/B的分数，要求A、B互质。表示可能的最大比例系数

>测试数据保证了输入格式正确，并且最大比例是存在的。

>例如，输入：
3
1250 200 32

>程序应该输出：
25/4

>再例如，输入：
4
3125 32 32 200

>程序应该输出：
5/2

>再例如，输入：
3
549755813888 524288 2

>程序应该输出：
4/1

>资源约定：
峰值内存消耗 < 256M
CPU消耗  < 3000ms

>请严格按要求输出，不要画蛇添足地打印类似：“请您输入...” 的多余内容。

>所有代码放在同一个源文件中，调试通过后，拷贝提交该源码。

>注意: main函数需要返回0
注意: 只使用ANSI C/ANSI C++ 标准，不要调用依赖于编译环境或操作系统的特殊函数。
注意: 所有依赖的函数必须明确地在源文件中 #include <xxx>， 不能通过工程设置而省略常用头文件。

>提交时，注意选择所期望的编译器类型。
>

###解题思路
暂时没写出来，等写出来了再补吧

#以上均为个人解答，非官方题解，仅供参考，如有错误，欢迎指出。